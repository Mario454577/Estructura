<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rutas Bolivar</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container">
        <h1>RUTAS BOLIVAR</h1>
        
        <div id="mainContainer">
            <div class="flex-layout" id="layoutContainer">
                <div class="sidebar">
                    <div class="card">
                        <div class="card-body">
                            <div id="results" style="display: none;">
                                <button type="button" class="btn btn-secondary mb-3" onclick="showRouteForm()">
                                        Volver
                                    </button>
                                <h5>Resultados del Cálculo</h5>
                                <div id="routeDetails"></div>
                                <div id="flowDetails"></div>
                            </div>

                            <div id="routeForm">
                                <h5>Calcular Ruta</h5>
                                <form onsubmit="calculateRoute(event)">
                                    <div class="mb-3">
                                        <label for="origin" class="form-label">Punto de Origen</label>
                                        <select class="form-select" id="origin" required>
                                            <option value="">Seleccione el punto de partida</option>
                                        </select>
                                    </div>
                                    <div class="mb-3">
                                        <label for="destination" class="form-label">Punto de Destino</label>
                                        <select class="form-select" id="destination" required>
                                            <option value="">Seleccione el punto de llegada</option>
                                        </select>
                                    </div>
                                    <div class="mb-3">
                                        <label for="algorithm" class="form-label">Algoritmo de Cálculo</label>
                                        <select class="form-select" id="algorithm" required>
                                            <optgroup label="Caminos más Cortos">
                                            <option value="dijkstra">Dijkstra - Ruta más Corta</option>
                                            <option value="bellman_ford">Bellman-Ford - Ruta Óptima</option>
                                            <option value="floyd_warshall">Floyd-Warshall - Todas las Rutas</option>
                                            <option value="a_star">A* - Búsqueda Heurística</option>
                                            <option value="johnson">Johnson - Rutas con Pesos Negativos</option>
                                            </optgroup>
                                            <optgroup label="Flujo Máximo">
                                                <option value="ford_fulkerson">Ford-Fulkerson - Flujo Básico</option>
                                                <option value="edmonds_karp">Edmonds-Karp - Flujo BFS</option>
                                                <option value="push_relabel">Push-Relabel - Flujo Avanzado</option>
                                            </optgroup>
                                        </select>
                                    </div>
                                    <div class="mb-3" id="criterionContainer">
                                        <label for="criterion" class="form-label">Criterio de Optimización</label>
                                        <select class="form-select" id="criterion">
                                            <option value="distancia">Distancia más Corta</option>
                                            <option value="tiempo">Tiempo más Rápido</option>
                                        </select>
                                    </div>
                                    <button type="submit" class="btn btn-primary w-100 mb-2">Calcular</button>
                                    <button type="button" class="btn btn-danger w-100" onclick="logout()">Salir</button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="main-content">
                    <div id="map"></div>
                    <div id="errorAlert" class="alert alert-danger mt-3" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div class="settings-icon" onclick="toggleSettings()" title="Configuración">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/>
                <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52l-.094-.319z"/>
            </svg>
        </div>

        <div class="settings-panel" id="settingsPanel">
            <h6 class="mb-3">Configuración</h6>
            <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" id="darkModeToggle">
                <label class="form-check-label" for="darkModeToggle">Modo Oscuro</label>
            </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="layoutToggle">
                <label class="form-check-label" for="layoutToggle">Mapa a la Izquierda</label>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        let map;
        let currentRoute = null;
        let currentMarkers = [];

        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            settingsPanel.classList.toggle('show');
        }

        function toggleDarkMode(enabled) {
            document.documentElement.setAttribute('data-theme', enabled ? 'dark' : 'light');
            localStorage.setItem('darkMode', enabled);
        }

        function toggleLayout(mapLeft) {
            const container = document.getElementById('layoutContainer');
            container.classList.toggle('reverse', mapLeft);
            localStorage.setItem('mapLeft', mapLeft);
            if (map) {
                map.invalidateSize();
            }
        }

        function initSettings() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const layoutToggle = document.getElementById('layoutToggle');

            const darkMode = localStorage.getItem('darkMode') === 'true';
            const mapLeft = localStorage.getItem('mapLeft') === 'true';

            darkModeToggle.checked = darkMode;
            layoutToggle.checked = mapLeft;
            toggleDarkMode(darkMode);
            toggleLayout(mapLeft);

            darkModeToggle.addEventListener('change', (e) => toggleDarkMode(e.target.checked));
            layoutToggle.addEventListener('change', (e) => toggleLayout(e.target.checked));

            document.addEventListener('click', (e) => {
                const panel = document.getElementById('settingsPanel');
                const icon = document.querySelector('.settings-icon');
                if (!panel.contains(e.target) && !icon.contains(e.target) && panel.classList.contains('show')) {
                    panel.classList.remove('show');
                }
            });
        }
        
        function initMap() {
            if (map) {
                map.remove();
            }
            map = L.map('map').setView([9.0, -74.8], 8);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
        }
        
        function clearMap() {
            if (currentRoute) {
                map.removeLayer(currentRoute);
                currentRoute = null;
            }
            currentMarkers.forEach(marker => map.removeLayer(marker));
            currentMarkers = [];
        }
        
        async function logout() {
            try {
                const response = await fetch('/logout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    window.location.href = '/';
                } else {
                    document.getElementById('errorAlert').textContent = data.message;
                    document.getElementById('errorAlert').style.display = 'block';
                }
            } catch (error) {
                document.getElementById('errorAlert').textContent = 'Error al cerrar sesión';
                document.getElementById('errorAlert').style.display = 'block';
            }
        }
        
        function showResults() {
            document.getElementById('routeForm').style.display = 'none';
            document.getElementById('results').style.display = 'block';
        }

        function showRouteForm() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('routeForm').style.display = 'block';
            initMap();
        }

        async function calculateRoute(event) {
            event.preventDefault();
            
            const origin = document.getElementById('origin').value;
            const destination = document.getElementById('destination').value;
            const algorithm = document.getElementById('algorithm').value;
            const criterion = document.getElementById('criterion').value;

            // Mostrar mensaje de carga
            document.getElementById('errorAlert').style.display = 'none';
            document.getElementById('routeForm').style.opacity = '0.5';
            
            // Mostrar mensaje de espera
            const loadingMessage = document.createElement('div');
            loadingMessage.className = 'alert alert-info';
            loadingMessage.id = 'loadingMessage';
            loadingMessage.innerHTML = `
                <div class="d-flex align-items-center">
                    <strong>Calculando ruta...</strong>
                    <div class="spinner-border ms-auto" role="status" aria-hidden="true"></div>
                </div>
            `;
            document.getElementById('routeForm').insertAdjacentElement('beforebegin', loadingMessage);
            
            try {
                const requestData = {
                    origin: origin,
                    destination: destination,
                    algorithm: algorithm,
                    criterion: criterion
                };
                
                console.log('Enviando solicitud:', requestData);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 segundos de timeout

                const response = await fetch('/calculate_route', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestData),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`Error HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Respuesta recibida:', data);
                
                if (data.status === 'success') {
                    // Limpiar el mapa actual
                    clearMap();
                    
                    try {
                        // Inicializar nuevo mapa
                        initMap();
                        
                        // Dibujar puntos y líneas en el mapa
                        if (data.route_data) {
                            // Dibujar rutas de flujo máximo
                            if (data.route_data.type === 'flow') {
                                const colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen'];
                                data.route_data.paths.forEach((pathInfo, index) => {
                                    const color = colors[index % colors.length];
                                    
                                    // Dibujar líneas
                                    for (let i = 0; i < pathInfo.path.length - 1; i++) {
                                        const start = pathInfo.path[i];
                                        const end = pathInfo.path[i + 1];
                                        const startCoords = data.route_data.coords[start];
                                        const endCoords = data.route_data.coords[end];
                                        
                                        if (startCoords && endCoords) {
                                            const points = [
                                                [startCoords.lat, startCoords.lon],
                                                [endCoords.lat, endCoords.lon]
                                            ];
                                            L.polyline(points, {
                                                color: color,
                                                weight: 2,
                                                opacity: 0.8
                                            }).addTo(map);
                                        }
                                    }
                                    
                                    // Agregar marcadores
                                    pathInfo.path.forEach(node => {
                                        const coords = data.route_data.coords[node];
                                        if (coords) {
                                            L.circleMarker(
                                                [coords.lat, coords.lon],
                                                {
                                                    radius: 6,
                                                    color: color,
                                                    fillColor: color,
                                                    fillOpacity: 0.7
                                                }
                                            ).bindPopup(node).addTo(map);
                                        }
                                    });
                                });
                            }
                            // Dibujar ruta más corta
                            else {
                                const path = data.route_data.path;
                                const points = path.map(node => {
                                    const coords = data.route_data.coords[node];
                                    return coords ? [coords.lat, coords.lon] : null;
                                }).filter(point => point !== null);
                                
                                if (points.length >= 2) {
                                    // Dibujar línea de la ruta
                                    L.polyline(points, {
                                        color: 'red',
                                        weight: 2,
                                        opacity: 0.8
                                    }).addTo(map);
                                    
                                    // Agregar marcadores
                                    path.forEach(node => {
                                        const coords = data.route_data.coords[node];
                                        if (coords) {
                                            L.circleMarker(
                                                [coords.lat, coords.lon],
                                                {
                                                    radius: 6,
                                                    color: node === origin || node === destination ? 'red' : 'blue',
                                                    fillColor: node === origin || node === destination ? 'red' : 'blue',
                                                    fillOpacity: 0.7
                                                }
                                            ).bindPopup(node).addTo(map);
                                        }
                                    });
                                }
                            }
                        }
                        
                        // Mostrar detalles de la ruta
                        if (algorithm === 'edmonds_karp' || algorithm === 'push_relabel' || algorithm === 'ford_fulkerson') {
                            let routeDetails = `<div class="alert alert-success">
                                <h6>Detalles del Flujo Máximo:</h6>
                                <p>Flujo máximo: ${data.details.max_flow.toFixed(2)}</p>
                                <p>Número de rutas: ${data.details.num_paths}</p>
                            </div>`;
                            
                            let flowDetails = `<div class="alert alert-info">
                                <h6>Rutas de Flujo:</h6>
                                <ul>
                                ${data.details.flow_paths.map(path => `
                                    <li>${path.path.join(' → ')} (Flujo: ${path.flow.toFixed(2)})</li>
                                `).join('')}
                                </ul>
                            </div>`;
                            
                            document.getElementById('routeDetails').innerHTML = routeDetails;
                            document.getElementById('flowDetails').innerHTML = flowDetails;
                        } else {
                            let routeDetails = `<div class="alert alert-success">
                                <h6>Detalles de la Ruta:</h6>
                                <p>Distancia total: ${data.details.distance.toFixed(2)} km</p>
                                <p>Tiempo estimado: ${Math.round(data.details.time)} minutos</p>
                                <p>Ruta: ${data.details.path}</p>
                            </div>`;
                            
                            document.getElementById('routeDetails').innerHTML = routeDetails;
                            document.getElementById('flowDetails').innerHTML = '';
                        }
                    
                    showResults();
                        
                        // Invalidar el tamaño del mapa para asegurar que se muestre correctamente
                        setTimeout(() => {
                            map.invalidateSize();
                        }, 100);
                    } catch (mapError) {
                        console.error('Error al procesar el mapa:', mapError);
                        document.getElementById('errorAlert').textContent = 'Error al mostrar el mapa: ' + mapError.message;
                        document.getElementById('errorAlert').style.display = 'block';
                    }
                } else {
                    document.getElementById('errorAlert').textContent = data.message;
                    document.getElementById('errorAlert').style.display = 'block';
                }
            } catch (error) {
                console.error('Error en la solicitud:', error);
                document.getElementById('errorAlert').textContent = 'Error al calcular la ruta: ' + error.message;
                document.getElementById('errorAlert').style.display = 'block';
            } finally {
                // Restaurar la opacidad del formulario
                document.getElementById('routeForm').style.opacity = '1';
                // Eliminar el mensaje de carga si existe
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) {
                    loadingMessage.remove();
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initSettings();
            
            fetch('/get_municipalities')
                .then(response => response.json())
                .then(municipalities => {
                    if (municipalities && municipalities.length > 0) {
                        const originSelect = document.getElementById('origin');
                        const destinationSelect = document.getElementById('destination');
                        
                        municipalities.sort().forEach(municipality => {
                            originSelect.add(new Option(municipality, municipality));
                            destinationSelect.add(new Option(municipality, municipality));
                        });
                    } else {
                        window.location.href = '/';
                    }
                });
            
            document.getElementById('algorithm').addEventListener('change', function(e) {
                const criterionContainer = document.getElementById('criterionContainer');
                const isFlowAlgorithm = ['edmonds_karp', 'push_relabel'].includes(e.target.value);
                criterionContainer.style.display = isFlowAlgorithm ? 'none' : 'block';
            });
        });
    </script>
</body>
</html> 